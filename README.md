[![Build Status](https://travis-ci.org/justCxx/ruby_interviews.svg)](https://travis-ci.org/justCxx/ruby_interviews)

Тестовые задачи
===============

1. В строке **S** из **N** символов правильно расставлены скобки, если:
  - **S** строка пустая;
  - **S** вида "(U)" где U строка с правильно расставленными скобками;
  - **S** вида "VW" где V и W строки с правильно расставленными скобками.

  Для примера в строке `"(()(())())"` скобки расставлены правильно, а в строке
  `"())"` нет.

  Необходимо написать функцию:
  ```ruby
  def solution(s)
  ```
  которая по строке из  **N** символов, вернет 1 если строка с правильно
  расставленными скобками и 0 в противном случае.

  Для примера,  для строки `"(()(())())"` функция должна вернуть 1, а для
  строки `"())"` - 0.

  Предполагаем:
  - **N**  число в диапазоне `[0..1,000,000]`;
  - строка **S** состоит только из символов `"("` и/или `")"`.

  Сложность алгоритма должна быть не более чем `O(N)` для худшего случая;

  [source](../master/tasks/task1.rb) | [test](../master/spec/task1_spec.rb)

2. Строка называется палиндромом если она имеет абсолютно одинаковую
  последовательность символов с права на лево и слева на право, для примера:
  - "kayak",
  - "abcba",
  - "neven".

  Строка **A** называется анаграммой к строке **B** если **A** может быть
  получена из **B** путем перестановки символов. Для примера строки из этих пар
  являются анаграммами к друг другу:

  - "mary" and "army",
  - "rocketboys" and "octobersky",
  - "divide" and "divide".

  Необходимо написать функцию:
  ```ruby
  def solution(s)
  ```

  которая для переданной непустой строки **S** состоящей из **N** символов
  вернет 1, если **S** - анаграмма какого-то полиндрома и вернет 0 в обратном
  случае.

  Предполагаем:
  - **N** число в диапазоне `[0..100,000]`;
  - строка **S** состоит только из латинских букв в нижнем регистре (a−z).

  Для примера, для строки `S = "dooernedrn"`, функция должна вернуть 1, так как
  `"dooernedrn"` анаграмма палиндрома "neroddoren". Для строки S = "aabcba",
  функция должна вернуть 0.

  Сложность алгоритма должна быть не более чем `O(N)` для худшего случая;

  [source](../master/tasks/task2.rb) | [test](../master/spec/task2_spec.rb)

3. Массив **A** состоит из **N** целых чисел. Тройка чисел `(P, Q, R)`
  называется треугольником если `0 ≤ P < Q < R < N` и:

  - `A[P] + A[Q] > A[R]`,
  - `A[Q] + A[R] > A[P]`,
  - `A[R] + A[P] > A[Q]`.

  Для примера рассмотрим массив A:
  ```
  A[0] = 10, A[1] = 2, A[2] = 5,
  A[3] = 1,  A[4] = 8, A[5] = 20
  ```
  Тройка `(0, 2, 4)` является треугольником.

  Необходимо написать функцию:
  ```ruby
  def solution(A);
  ```

  которая для массива целых чисел из **N** элементов вернет 1 если существует
  треугольник в массиве и вернет 0 в обратном случае.

  Для примера массив A:
  ```
  A[0] = 10, A[1] = 2, A[2] = 5
  A[3] = 1,  A[4] = 8, A[5] = 20
  ```
  функция должна вернуть 1 (пример выше).

  Для такого массива:
  ```
  A[0] = 10    A[1] = 50    A[2] = 5
  A[3] = 1
  ```
  функция должна вернуть 0.

  Предполагаем:

  - **N** число в диапазоне `[0..1,000,000]`;
  - каждый элемент массива **A** целое число в диапазоне
    `[−2,147,483,648..2,147,483,647]`.

  Требования по сложности алгоритма:

  - в худшем случае время выполнения должно быть `O(N * log(N))`;
  - в худшем случае памяти должно использоваться `O(N)`.

  Элементы массива можно модифицировать.

  [source](../master/tasks/task3.rb) | [test](../master/spec/task3_spec.rb)
